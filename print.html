<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Roux Tutorial</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="beginners/beginners.html"><strong aria-hidden="true">1.</strong> Beginners</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginners/notation.html"><strong aria-hidden="true">1.1.</strong> Notation</a></li><li class="chapter-item expanded "><a href="beginners/first-block.html"><strong aria-hidden="true">1.2.</strong> First Block</a></li><li class="chapter-item expanded "><a href="beginners/second-block.html"><strong aria-hidden="true">1.3.</strong> Second Block</a></li><li class="chapter-item expanded "><a href="beginners/cmll.html"><strong aria-hidden="true">1.4.</strong> CMLL</a></li><li class="chapter-item expanded "><a href="beginners/lse.html"><strong aria-hidden="true">1.5.</strong> Last Six Edges</a></li></ol></li><li class="chapter-item expanded "><a href="intermediate/intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intermediate/first-block.html"><strong aria-hidden="true">2.1.</strong> First Block</a></li><li class="chapter-item expanded "><a href="intermediate/second-block.html"><strong aria-hidden="true">2.2.</strong> Second Block</a></li><li class="chapter-item expanded "><a href="intermediate/cmll.html"><strong aria-hidden="true">2.3.</strong> CMLL</a></li><li class="chapter-item expanded "><a href="intermediate/lse.html"><strong aria-hidden="true">2.4.</strong> LSE</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roux Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the world of Roux! This method is a good option to go to as both a beginner and as someone switching from another method such as CFOP.</p>
<p>This tutorial will be split into two parts, the first being a completely beginner oriented approach, and the second being for more intermediate solvers with knowledge of how the cube works.</p>
<p>Even if you don't end up switching to Roux, the cubing knowledge that you get from it can still help improve your speed with other methods - they don't become sunk costs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginners"><a class="header" href="#beginners">Beginners</a></h1>
<p>Here is the guide for complete beginners on how to solve the Rubik's cube using the Roux Method.</p>
<p>Make sure to read the <a href="beginners/./beginners/notation.html">notation</a> page if you don't know any notation, but even if you're not too confident with them, the interactive cube can still be very helpful.</p>
<h2 id="cube-pieces"><a class="header" href="#cube-pieces">Cube Pieces</a></h2>
<p>Each 3x3 cube has <code>3</code> distinct cube types:</p>
<ol>
<li>Corner pieces
<ul>
<li>There are <code>8</code> corner pieces on each cube, and each corner piece has <code>3</code> different colours on them.</li>
</ul>
</li>
<li>Edge pieces
<ul>
<li>There are <code>12</code> edge pieces on each cube, with each edge piece having <code>2</code> different colours on them.</li>
</ul>
</li>
<li>Centers
<ul>
<li>There are <code>6</code> centers on each cube, with each center consisting of just <code>1</code> colour.`</li>
<li>No matter how much you mess the cube up, the <em>orientation</em> of the centers remains identical — white opposite yellow, blue opposite green, and red opposite orange</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="move-notation"><a class="header" href="#move-notation">Move Notation</a></h1>
<blockquote>
<p>TL;DR: <a href="https://assets1.ello.co/uploads/asset/attachment/4123434/ello-optimized-81fbd399.gif">Look at this link for a .gif on all the possible cube moves.</a>.</p>
<p>If you ever need any visual cube representation of what would happen to the cube when you input typed moves, use <a href="https://cubedb.net/">cubedb.net</a></p>
</blockquote>
<h2 id="basic-moves"><a class="header" href="#basic-moves">Basic Moves</a></h2>
<p>If you hold the cube in a fixed position, there are 6 sides of the cubes that can be turned, which are the following:</p>
<ol>
<li>Top/Up (<code>U</code>)</li>
<li>Left (<code>L</code>)</li>
<li>Front (<code>F</code>)</li>
<li>Right (<code>R</code>)</li>
<li>Back (<code>B</code>)</li>
<li>Bottom/Down (<code>D</code>)</li>
</ol>
<p>In addition, there are 3 different types of arguments that can be applied to the end of each move to change how that move is executed:</p>
<ol>
<li>Single Letter (Turn clockwise)</li>
<li>Single Letter + <code>'</code> (Turn face anticlockwise)</li>
<li>Single Letter + <code>2</code> (Do a double turn on that face)</li>
</ol>
<blockquote>
<p>Some of the direction of the moves might be counter-intuitive in the beginning, for example <code>D</code> and <code>B</code> moves. The way to see which direction these moves go in is to have the <code>D</code> or <code>B</code> side face you, then turn that face either clockwise or anticlockwise depending on the argument provided.</p>
</blockquote>
<p>A good way to familiarize yourself with the notation is to see it in action. Below you can see a few examples of what the notation looks like! (Pay attention to the direction that the moves go in, and also try executing them on your own cube)</p>
<h3 id="u-moves"><a class="header" href="#u-moves">U moves</a></h3>
<div id="U">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`U U' U2`)
    ('#U');
</script>
<h3 id="l-moves"><a class="header" href="#l-moves">L moves</a></h3>
<div id="L">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`L L' L2`)
    ('#L');
</script>
<h3 id="f-moves"><a class="header" href="#f-moves">F moves</a></h3>
<div id="F">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`F F' F2`)
    ('#F');
</script>
<h3 id="r-moves"><a class="header" href="#r-moves">R moves</a></h3>
<div id="R">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R R' R2`)
    ('#R');
</script>
<h3 id="b-moves"><a class="header" href="#b-moves">B moves</a></h3>
<div id="B">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`B B' B2`)
    ('#B');
</script>
<h3 id="d-moves"><a class="header" href="#d-moves">D moves</a></h3>
<div id="D">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`D D' D2`)
    ('#D');
</script>
<h2 id="rotations"><a class="header" href="#rotations">Rotations</a></h2>
<p>There also is notation to rotate the <strong>whole</strong> cube along the <code>x</code>, <code>y</code>, and <code>z</code> axes.</p>
<p>You could imagine rotating the cube around those axes, but a potentially easier way to remember the direction of the rotations is to realize that <code>x</code>, <code>y</code>, and <code>z</code> follow the direction of <code>R</code>, <code>U</code>, and <code>F</code> respectively. You could imagine an <code>x'</code> rotation like doing an <code>R'</code> move, but on <strong>all</strong> the layers rather than just the outer layer. If you're still confused, look at the visual representations:</p>
<h3 id="x-rotations"><a class="header" href="#x-rotations">x rotations</a></h3>
<div id="x">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`x x' x2`)
    ('#x');
</script>
<h3 id="y-rotations"><a class="header" href="#y-rotations">y rotations</a></h3>
<div id="y">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`y y' y2`)
    ('#y');
</script>
<h3 id="z-rotations"><a class="header" href="#z-rotations">z rotations</a></h3>
<div id="z">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`z z' z2`)
    ('#z');
</script>
<h2 id="moves-useful-for-the-roux-method"><a class="header" href="#moves-useful-for-the-roux-method">Moves useful for the Roux Method</a></h2>
<p>There are some additional pieces of notation that can be derived by using a combination of a <em>move</em> and a <em>rotation</em>, but in the context of Roux solving, it is far easier to deal with it by learning new notation that covers those specific moves. </p>
<p>These moves are the middle slice move <code>M</code>, and the wide R move <code>Rw</code> or <code>r</code>. While there are some other versions of these moves, you only really need to know the moves mentioned above for the Roux method. A visual representation of the moves can be seen below:</p>
<h3 id="m-slice-moves"><a class="header" href="#m-slice-moves">M slice moves</a></h3>
<p>Notice that the direction is somewhat counter-intuitive! <code>M</code> follows the direction of <code>L</code> moves rather than <code>R</code> moves, so take some time to get used to that.</p>
<p>It is worth noting that knowing the direction of <code>M</code> will not be necessary to solve the cube due to the intuitive nature of Roux (the visuals should be good enough), but it may help in the future.</p>
<div id="M">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`M M' M2`)
    ('#M');
</script>
<h3 id="wide-r-moves"><a class="header" href="#wide-r-moves">Wide R moves</a></h3>
<p><code>Rw</code> and <code>r</code> are functionally the exact same on a 3x3. <code>r</code> is shorter, so this tutorial will use <code>r</code> throughout, but if you see <code>Rw</code> somewhere else on a 3x3 related tutorial, know that they are the same thing.</p>
<div id="Rw">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`r r' r2`)
    ('#Rw');
</script>
<blockquote>
<p>The <code>w</code> in <code>Rw</code> stands for 'wide'</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="first-block"><a class="header" href="#first-block">First Block</a></h1>
<h2 id="objective"><a class="header" href="#objective">Objective</a></h2>
<p>The goal of First Block (FB) is to solve a <code>2x3x1</code> block on the left side of the cube.</p>
<p>Below is a visual cube showing what an FB looks like that you can move around - try it yourself!</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#inf1');
</script>
<p>This tutorial will use the <strong>same orientation for all first blocks</strong>. This means that for every example, the Blue-White first block will be the one to solve (check the visual if you aren't sure what that means)</p>
<h2 id="steps-to-solving-fb"><a class="header" href="#steps-to-solving-fb">Steps to Solving FB</a></h2>
<h3 id="orient-your-centers"><a class="header" href="#orient-your-centers">Orient your Centers</a></h3>
<p>In this step, all you need to do is rotate the cube such that the blue center is on the left, and the green center is on the right.</p>
<p>After you do this, you should not change the position of the left and right centers throughout the whole solve — they should be fixed with blue on left and green on right even up until the cube is fully solved.</p>
<p>Your cube's centers should look like that in the visual below.</p>
<div id="centers">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttgttttttttttttttttttttttttttbttttttttttttt')
    ('#centers');
</script>
<blockquote>
<p>Notice that you only need to look at the green and blue centers! No other center colours matter until the last step.</p>
</blockquote>
<h3 id="solve-the-white-blue-edge-piece"><a class="header" href="#solve-the-white-blue-edge-piece">Solve the White-Blue edge piece</a></h3>
<p>The first step is to solve the white-blue edge piece relative to its center. Once you're done, the white facelet should be facing downwards.</p>
<p>Note that the blue facelet on the blue-white edge should match with the blue center — not the other way around.</p>
<p>Below, you will see a few examples of how to insert the blue-white edge in place.</p>
<h4 id="example-1-move-away"><a class="header" href="#example-1-move-away">Example: 1 move away</a></h4>
<div id="DL">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('D2')
    ('#DL');
</script>
<h4 id="example-l2-away"><a class="header" href="#example-l2-away">Example: L2 away</a></h4>
<div id="DL-L2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('L2')
    ('#DL-L2');
</script>
<h4 id="example-weird-position"><a class="header" href="#example-weird-position">Example: Weird position</a></h4>
<div id="DL-weird">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`B' D`)
    ('#DL-weird');
</script>
<h4 id="example-edge-flipped-in-place"><a class="header" href="#example-edge-flipped-in-place">Example: Edge flipped in place</a></h4>
<div id="DLflip">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('D F L')
    ('#DLflip');
</script>
<p><code>or</code></p>
<div id="DLflip2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`L2 U' r' D'`)
    ('#DLflip2');
</script>
<p>(There are many possibilities — just experiment and see what works.)</p>
<h3 id="building-the-first-block-square-2x1x1"><a class="header" href="#building-the-first-block-square-2x1x1">Building the First Block Square (2x1x1)</a></h3>
<p>Once you're done with that, you're ready to move onto solving a <code>2x1x1</code> using either the Blue-Red-White or Blue-Orange-White pairs.</p>
<p>To do that, we first need to know what a <code>pair</code> is.</p>
<h4 id="what-is-a-pair"><a class="header" href="#what-is-a-pair">What is a pair?</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-block"><a class="header" href="#second-block">Second Block</a></h1>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="cmll"><a class="header" href="#cmll">CMLL</a></h1>
<h2 id="objective-1"><a class="header" href="#objective-1">Objective</a></h2>
<p>The goal of CMLL (Corners of the Last Layer, in essence) is to solve the corners on the <code>U</code> layer — both oriented (all yellow on top) and permuted (all the facelets on the side of the corners are completely solved relative to each other) as shown in the figure below.</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#inf1');
</script>
</div>
<p>This step will be separated into 2 steps, both of which need 1 algorithm each.</p>
<h2 id="orienting-the-corners"><a class="header" href="#orienting-the-corners">Orienting the corners</a></h2>
<div id="orient">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    ('#orient');
</script>
</div>
<p>In this step, all you need to worry about are the <strong>yellow</strong> facelets — the side colours (marked in gray) do not matter. </p>
<p>For this step, using the <code>sune</code> algorithm (sometimes multiple times) will be able to orient the corners. </p>
<div id="SUNE">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    .case(`R U R' U R U2 R'`)
    ('#SUNE');
</script>
<p>One way to learn the algorithm is to think of taking the pair out with <code>R U R'</code>, then setting up to another insertion with a <code>U</code> move, then inserting the last pair by doing <code>R U2 R'</code>.</p>
<p>For a more visual representation:</p>
<p>Applying <code>R U R'</code> takes the pair out,</p>
<div id="rur">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlltltttltlbbbbbbltlotootoltl')
    .alg(`R U R'`)
    ('#rur');
</script>
<p>And inserting with <code>R U2 R'</code> puts the pair back in through another insertion.</p>
<div id="ru2r">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlltltttltlbbbbbbltlotootoltl')
    .case(`R U2 R'`)
    ('#ru2r');
</script>
<p>So all that needs to be linked together is to just do one extra setup move in between the two cases, and you have learned the algorithm.</p>
<p>It's also reasonable to learn this by muscle memory/brute force, but I highly recommend trying to think of it as pair insertions, especially because it is easier to remember in the long term.</p>
<p>If you look at the first visual though, the algorithm twists all but the bottom left corner clockwise, which means that your end goal in this step is to end up with <strong>only 1 corner oriented</strong>, from which you can then apply the <code>sune</code> algorithm either once or twice (depending on whether the corners need to be twisted counter-clockwise or clockwise) to orient all the corners.</p>
<h3 id="memorization-approach"><a class="header" href="#memorization-approach">Memorization Approach</a></h3>
<p><img src="https://i.imgur.com/IIYopnA.png" alt="" /></p>
<p>To follow this visual, first look at how many misoriented corners you have, then look and see which case it corresponds to, then just do some pattern matching and execute the algorithm in the visual (all 3 cases use the same algorithm - they eventually reduce to the case where there's one corner oriented, which then leads to a case where we can solve corner orientation fully.)</p>
<h3 id="intuitive-approach"><a class="header" href="#intuitive-approach">Intuitive Approach</a></h3>
<p>How do we get there then? One approach would be to check all <code>4</code> different possibilities and see which one leads to you having just <code>1</code> oriented corner in total. Let's take a look at some examples:</p>
<p>In the visual below, you can move the cube by a <code>U</code> move by pressing the forward and backward buttons.</p>
<div id="L">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    .case(`U R U R' U' R' F R F'`)
    .alg(`U U U`)
    .showAlg(false)
    ('#L');
</script>
<p>For our first angle, imagine twisting all the corners but the bottom left one clockwise: what you see is that the bottom right corner twists such that yellow is facing you, the top right corner twists such that it's facing away from you, and the top left corner twists such that it's facing leftwards. As a result, no corners are oriented, which means we do not want to execute <code>sune</code> from this angle.</p>
<p>From the second angle, imagine the same process - the bottom right corner ends up facing right, the top right corner ends up facing away from you, and the top left corner ends up facing upwards. In sum, we only have 1 oriented corner in this step, which means that this is the angle to execute <code>sune</code> from.</p>
<p>For completion’s sake, I'll also go through the process for the other two angles.</p>
<p>From the third angle, the bottom left corner faces right, the top right corner faces up, and the top left corner faces away from you — in sum, we have 2 oriented edges, so this is not the correct angle.</p>
<p>From the fourth angle, the bottom right corner faces up, the top right corner faces right, and the top left corner faces left — in sum we have 2 oriented edges once again.</p>
<hr />
<p>After getting only one corner oriented, all that you need to do is put the oriented corner in the bottom left, then apply the <code>sune</code> algorithm again. For example if we do <code>sune</code> from the angle shown in the visual below, the bottom right corner will be facing us, the top right corner will face right, and the top left corner will face away from us. From this, there will still only be a total of 1 corner oriented, which means we can then apply the same algorithm from a different angle to solve corner orientation.</p>
<div id="S2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    .case(`U2 R U2 R' U' R U' R'`)
    .alg(`R U R' U R U2 R'`)
    ('#S2');
</script>
<p>Notice how after the algorithm is done, there is still only 1 corner oriented? From there, we can then apply <code>sune</code> again after moving the <code>U</code> layer such that we have the 1 oriented corner in the bottom left.</p>
<div id="S1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    .case(`U2 R U R' U R U2 R'`)
    ('#S1');
</script>
<h2 id="permuting-the-corners"><a class="header" href="#permuting-the-corners">Permuting the Corners</a></h2>
<p>After the corners are oriented, we can finally deal with permuting them. What this step entails is memorizing another (slightly longer) algorithm — however, there are fewer cases and by extension, mental gymnastics to deal with. </p>
<p>The algorithm is <code>R U R' U' R' F R2 U' R' U' R U R' F'</code> as seen in the visual below:</p>
<div id="t">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    .case(`R U R' U' R' F R2 U' R' U' R U R' F'`)
    ('#t');
</script>
<p>What it does is swaps the two corners on the right with each other, while preserving the solved 'headlights' on the left side of the cube. If you look at the blue stickers in the visual, you notice that they are both on the same face? That's what's called <code>headlights</code>.</p>
<p>In general, you can just find the <code>headlights</code>, then do <code>U</code> moves until the headlights are on the left, and then do the algorithm for permuting the corners.</p>
<p><strong>If you do not see any headlights</strong>, simply just do the algorithm, and you will then see headlights appear. If you want, you can trace why that works by looking at swapping any 2 pieces, but this isn't particularly important. </p>
<p><img src="https://i.imgur.com/BgTHffg.png" alt="" /></p>
<p>Here's a visual representation if you need one.</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="lse"><a class="header" href="#lse">LSE</a></h1>
<h2 id="objective-2"><a class="header" href="#objective-2">Objective</a></h2>
<p>In this step, the goal is to solve the last six edges, which will actually end up solving the entire cube!</p>
<h2 id="edge-orientation-eo"><a class="header" href="#edge-orientation-eo">Edge Orientation (EO)</a></h2>
<p>The first 'step' of LSE is to orient all the edges — making the white and yellow edges face either upwards or downwards. The colours on the other side of the edge does not matter for this step.</p>
<div id="eo">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwggggggglgrlrrrrrlryyyyyyyyybbbbbbblbolooooolo')
    .case(`M2 U2 M U2 M U' M2 U M2 U M' U2 M'`)
    ('#eo');
</script>
</div>
<p><strong>Make sure you have either the white center or the yellow center on the U layer!</strong> Correct edge orientation depends on this being the case — if it isn't, the remaining steps are going to not behave as normal as the edges aren't going to be oriented <em>relative to the centers</em>.</p>
<table><thead><tr><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">Oriented Edge/Good Edge</td><td align="left">Edge where the white/yellow sticker is facing either upwards or downwards.</td></tr>
<tr><td align="left">Misoriented Edge/Bad Edge</td><td align="left">Edge where the white/yellow sticker is <strong>not</strong> facing either upwards or downwards.</td></tr>
</tbody></table>
<p>In this step, we only need to use <code>M</code> and <code>U</code> moves - no other moves are needed.</p>
<p>There are still a few things we need to learn to make solving the rest of the cube easier:</p>
<h3 id="solving-the-arrow-case"><a class="header" href="#solving-the-arrow-case">Solving the 'arrow' case</a></h3>
<p>If you have 3 misoriented edges on the <code>U</code> layer and 1 misoriented edge on the <code>D</code> layer, you have an <code>arrow</code>. Looking at the misoriented edges on the <code>U</code> layer, you can sort of see a <code>V</code> shape which looks like an arrow. To get from this case to all edges oriented, you need to do the following steps:</p>
<ol>
<li>Bring the tip of the <code>V</code> on the <code>U</code> layer above the misoriented edge on the <code>D</code> layer. We will call the edge representing the tip of the arrow and the misoriented edge on the <code>D</code> layer the 'edges in question'</li>
<li>Bring both of the edges in question to the <code>U</code> layer by either doing <code>M</code> or <code>M'</code></li>
<li>Do either <code>U</code> or <code>U'</code> (does not make a difference)</li>
<li>Do an <code>M</code> move <strong>in the opposite direction</strong> of what you did in step 2.</li>
</ol>
<div id="frontarrow">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwggggggglgrlrrrrrlryyyyyyyyybbbbbbblbolooooolo')
    .case(`U M' U M`)
    ('#frontarrow');
</script>
</div>
<div id="backarrow">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwggggggglgrlrrrrrlryyyyyyyyybbbbbbblbolooooolo')
    .case(`U' M U M'`)
    ('#backarrow');
</script>
</div>
<p>This turns a case from having <code>4</code> misoriented edges to having none of the edges misoriented.</p>
<p>Another extremely important concept in this step is an algorithm that <em>swaps</em> one of the edges in the <code>U</code> layer with one of the edges in the <code>D</code> layer while preserving our edge orientation. We'll call this the swapping algorithm.</p>
<blockquote>
<p>This can either be done by swapping the front two edges or the back two edges</p>
</blockquote>
<p>To do this, we do the following steps:</p>
<ol>
<li>Bring the edge in the <code>U</code> layer that we want to swap above the edge in the <code>D</code> layer that we want swapped.</li>
<li>Do either <code>M</code> or <code>M'</code> to bring them both to the <code>U</code> layer</li>
<li>Do a <code>U2</code></li>
<li>Do an <code>M</code> move <strong>in the opposite direction</strong> of what you did in step 2.</li>
</ol>
<p>Notice how the steps are extremely similar to the <code>arrow</code> case from earlier? If you try to remember these two cases as one larger case, you'll have an easier time memorizing these cases.</p>
<div id="frontmu2m">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M`)
    ('#frontmu2m');
</script>
</div>
<div id="backmu2m">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U2 M'`)
    ('#backmu2m');
</script>
</div>
<p>After you know both these cases, you can finally move onto solving edge orientation!</p>
<hr />
<h3 id="flowchart-approach"><a class="header" href="#flowchart-approach">Flowchart Approach</a></h3>
<p>This approach requires more memorization than the intuitive approach below, but is still not a lot of pure memorization --- it's possible to brute force solve this step if you're stuck unlike the CMLL step from earlier.</p>
<p>In the visual below, the red coloured edges represent <strong>misoriented</strong> edges. In some of the visuals, you may not be able to see all the misoriented edges, but one feature of the cube is that there can only be an even number of misoriented and oriented edges in sum. </p>
<p>All these cases lead to the <code>arrow</code>, which you can then solve intuitively from there.</p>
<p><img src="https://i.imgur.com/97lzRoZ.png" alt="" /></p>
<p>Remember that <code>M</code> moves follow the direction of <code>L</code> moves rather than <code>R</code> moves - this is a bit weird but because it's conventional, that's the way its done now.</p>
<h3 id="intuitive-approach-1"><a class="header" href="#intuitive-approach-1">Intuitive Approach</a></h3>
<p>The general way to get to all edges oriented is to set up to an <code>arrow</code> case, where there are three misoriented edges on the top layer, and one misoriented edge on the bottom layer. With this method, we will need just the arrow and the swapping algorithms and a bit of counting.</p>
<p>We want to end up with <code>4</code> misoriented edges in total, which means we want to do the arrow alg in a position where we will eventually end up with 4 misoriented edges.</p>
<div id="frontmu2m1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M`)
    ('#frontmu2m1');
</script>
</div>
<p>If you look at the front two edges (yellow-red and yellow-white edges), you can see that by doing <code>M' U2 M</code>, they swap positions.</p>
<div id="frontmu2mmisoriented">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U' M U M'`)
    .alg(`M' U2 M`)
    ('#frontmu2mmisoriented');
</script>
</div>
<p>Notice how after doing <code>M' U2 M</code> on the cube, the visual goes from having 3 misoriented edges on the top layer and 1 misoriented edge on the bottom layer to having 2 on top and 2 on bottom. In the example above, the red-white and orange-yellow edges swap position.</p>
<p>You can also do the swapping 'algorithm' from the back similarly to the arrow case.</p>
<div id="backmu2m1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U2 M'`)
    ('#backmu2m1');
</script>
</div>
<hr />
<h3 id="example-1"><a class="header" href="#example-1">Example 1:</a></h3>
<p>Knowing this information, let's try our hand at some LSE cases:</p>
<div id="case1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U M U M U M' U M`)
    .alg(`U' U' U'`)
    .showAlg(false)
    ('#case1-1');
</script>
</div>
<p>First, check to see how many misoriented edges there are — 2.</p>
<blockquote>
<p>Hint: the number of misoriented edges will ALWAYS be an even number; likewise for oriented edges.</p>
</blockquote>
<p>Then, remember that your goal is to do the arrow alg such that you can get to 4 misoriented edges in total. If you remember what edges the arrow cases flip, you can basically check to see what your end case will become.</p>
<p>From the first angle in the visual, if you do an arrow in the front, you will end up flipping two oriented edges and two misoriented edges, leaving you with a total of two misoriented edges, which means that it isn't the correct angle. <strong>However</strong>, if you do an arrow from the back, you flip one misoriented edge and three oriented edges, which in total leads to four misoriented edges if you include the misoriented edge that does not get affected in the front.</p>
<p>From the second angle, doing the arrow in the front leads to two misoriented edges, and doing it from the back leads to six misoriented edges, so we can ignore this angle.</p>
<p>The third angle is just a mirror of the first angle, so the same thing applies (just see for yourself).</p>
<p>In the fourth angle, if you do an arrow in the front, you end up flipping one misoriented edge and three oriented edges, leaving you with four misoriented edges in total. If you do an arrow in the back, you end also end up flipping one misoriented edge and three oriented edges, leaving you with four in total too.</p>
<p>After executing the arrow alg from the correct angle (in this case, <code>M U' M'</code>), we get the case in the visual below:</p>
<div id="case1-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U M U M U M' U M`)
    .alg(`M U' M'`)
    ('#case1-2');
</script>
</div>
<p>Notice how there are <strong>four</strong> bad edges in total, however we don't have the arrow case directly because we have two misoriented on the top, and two on the bottom, so we will have to do some swaps in order to set up to an arrow. In this case, we want to swap one of the oriented edges on the <code>U</code> layer with one of the misoriented edges on the <code>D</code> layer.</p>
<p>In the example below, the back two edges will be swapped, leading to an arrow case, which from there can lead to finishing EO.</p>
<div id="case1-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U M' U M U M U M' U M`)
    .alg(`M U2 M' U2 M' U M`)
    ('#case1-3');
</script>
</div>
<p>Doing <code>M U2 M'</code> swaps the back two, making an arrow case. From there, <code>U2</code> sets up to the correct angle for the arrow case, from which <code>M' U M</code> solves the arrow case fully.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example 2:</a></h3>
<div id="case2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`R U' r' U' M' U r U r'`)
    .alg(`U' U' U'`)
    .showAlg(false)
    ('#case2-1');
</script>
</div>
<p>In this case, we start off with all the edges misoriented. You can do the arrow from any angle here, because no matter what <code>U</code> move you do, you still have the same six misoriented edges.</p>
<div id="case2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`R U' r' U' M' U r U r'`)
    .alg(`M' U M`)
    ('#case2-2');
</script>
</div>
<p>From here, we have one misoriented on top and one misoriented on bottom, which is the same as the example shown earlier. From here you can just follow the same steps as Example 1.</p>
<div id="case2-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U' M R U' r' U' M' U r U r'`)
    .alg(`U2 M U M'`)
    ('#case2-3');
</script>
</div>
<p>Setup to arrow, then</p>
<div id="case2-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U' M' U2 M' U' M R U' r' U' M' U r U r'`)
    .alg(`U M U M'`)
    ('#case2-4');
</script>
</div>
<p>solve EO!</p>
<hr />
<h2 id="solving-the-left-and-right-edges"><a class="header" href="#solving-the-left-and-right-edges">Solving the Left and Right edges</a></h2>
<p>In this step, the aim is to solve the edges that are part of the left and right sides of the cube. Due to the fact that we always start with the blue-white first block, this means that the edges in question are the green-yellow and blue-yellow edges. </p>
<p>The simplest, and typically most efficient, approach is to put both the green-yellow and blue-yellow edges on the bottom layer, then doing an <code>M2</code> from the correct angle to solve the edges.</p>
<div id="ulur1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M U M U2 M' M2 U2 M U2 M U' M2 U2 M2 U M' U2 M' U M2 U M' U2 M' U2 M U2 M'`)
    .alg(`M' U2 M`)
    ('#ulur1');
</script>
</div>
<p>For example, you can do <code>M' U2 M</code> (front swap) here to bring the green-yellow edge to the <code>D</code> layer in the front.</p>
<div id="ulur2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M U M U2 M' M2 U2 M U2 M U' M2 U2 M2 U M' U2 M' U M2 U M' U2 M' U2 M U2 M'`)
    .alg(`M' U2 M`)
    ('#ulur2');
</script>
</div>
<p>Afterwards, <code>U M U2 M'</code> (setup to back swap) will put the blue-yellow edge to the <code>D</code> layer in the back such that both of the edges in question are located in the <code>D</code> layer:</p>
<div id="ulur3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U M U2 M' M2 U2 M U2 M U' M2 U2 M2 U M' U2 M' U M2 U M' U2 M' U2 M U2 M'`)
    .alg(`U M U2 M'`)
    ('#ulur3');
</script>
</div>
<p>After you get both of the edges onto the bottom layer, all that's left is to move the corners with <code>U</code> moves until doing an <code>M2</code> will solve the edges relative to their corners.</p>
<p>In this case, <code>U'</code> will move the corners to the correct position:</p>
<div id="ulur4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U2 M' U' U M U2 M' M2 U2 M U2 M U' M2 U2 M2 U M' U2 M' U M2 U M' U2 M' U2 M U2 M'`)
    .alg(`U' M2'`)
    ('#ulur4');
</script>
</div>
<hr />
<p>Small shortcut: you can actually do an <code>M2</code> to insert the first edge onto the <code>D</code> layer as long as your other edge isn't there. However, if you can't grasp this, stick with just doing the swapping algorithm for now.</p>
<h2 id="finishing-the-rest-of-the-cube"><a class="header" href="#finishing-the-rest-of-the-cube">Finishing the rest of the cube</a></h2>
<p>You're nearly there!</p>
<p>Due to the properties of the Rubik's cube, if you solve the bottom two edges (including the centers), the rest of the cube will automatically solve itself. Sound familiar?</p>
<p>All you need to do is make sure the white center is on bottom (if it's not, you just need to do an <code>M2</code> to put white on bottom), then from there, do the swapping algorithm to put the <strong>white</strong> edges in their correct places - in other words, solve them into their position. Afterwards, the cube solves itself. Let's take a look at some examples:</p>
<div id="end1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M`)
    .alg(`M' U2 M`)
    ('#end1');
</script>
</div>
<p>Here we just need to solve one of the white edges because the other one is already solved in place.</p>
<div id="end2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M'`)
    .alg(`M2 M U2 M'`)
    ('#end2');
</script>
</div>
<p>Here <code>M2</code> first puts the white center on the bottom, then we can put the edges in their correct position.</p>
<div id="end3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M2 U2 M' U2 M`)
    .alg(`M2 U2 M' U2 M`)
    ('#end3');
</script>
</div>
<p>In this case, <code>M2</code> puts the white center on the bottom, and after that, on the <code>U</code> layer we only see one white edge (in this case the white-red edge), so when we want to solve it in place, we first need to move the edge to its position (which is in the axis where the white and red centers are), then swap the edges in question (which in this case is the front 2)</p>
<div id="end4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M2 U2 M'`)
    .alg(`M' U2 M M U2 M'`)
    ('#end4');
</script>
</div>
<p>You can see here that the two white edges on the <code>U</code> layer are already directly above their solved position, so we just need to swap the front two edges, then swap the back two edges.</p>
<div id="end5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M2 U2 M2 U2`)
    .alg(`M' U2 M U2 M U2 M' U2 M' U2 M U2`)
    ('#end5');
</script>
</div>
<p>The first <code>M' U2 M</code> brings one of the white edges to the <code>U</code> layer because we need to have one there to be able to execute swaps, then afterwards, we see that the edge that gets kicked out (the white-orange edge) needs to go to the back, so we can do <code>U2</code> to align the edge, then do a back swap (<code>M U2 M'</code>), then afterwards the white-red edge gets kicked out to the <code>U</code> layer, which from there, we can then align it with its position in the front with <code>U2</code>, then do a front swap (<code>M' U2 M</code>), then just do the last move to solve the rest of the cube.</p>
<blockquote>
<p>This case can actually be solved by doing <code>M2 U2 M2 U2</code> which directly solves both the white edges at the same time - but this isn't too important to learn for now.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h1>
<p>Here is the guide for experienced cubers wanting to learn how to do the Roux Method.</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="first-block-1"><a class="header" href="#first-block-1">First Block</a></h1>
<h2 id="objective-3"><a class="header" href="#objective-3">Objective</a></h2>
<p>The goal of First Block (FB) is to solve a <code>2x3x1</code> block on the left side of the cube.</p>
<p>Below is a visual cube showing what an FB looks like that you can move around - try it yourself!</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#inf1');
</script>
<p>This tutorial will use the same orientation for all first blocks, but to make the most of each scramble, be able to solve with yellow/white on bottom with any color on the side at the minimum (x2 y color neutrality). If you come from a CN CFOP background, it might be worth it to go for full CN right from the beginning.</p>
<p>This step should be fairly simple if you have a background in cubing, but it is still highly recommended that you read the examples below.</p>
<h2 id="approaches-to-solving-fb"><a class="header" href="#approaches-to-solving-fb">Approaches to solving FB</a></h2>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<table><thead><tr><th>Approach</th><th>Explanation</th></tr></thead><tbody>
<tr><td>DL First</td><td>Solve the DL Piece first (for this guide, the blue-white edge), then solve the two remaining pairs.</td></tr>
<tr><td>Line-Line 2x2x1 + Pair</td><td>Build a <code>2x2x1</code> square by using a form of <code>D</code> or <code>Uw</code> move at the end, then solve the last remaining pair.</td></tr>
<tr><td>S Move Insert</td><td>Using an <code>S</code> move to make a square or a full FB</td></tr>
<tr><td>Line-Line</td><td>Solving two <code>1x1x3</code> lines then solving them using a form of <code>D</code> or <code>Uw</code> moves.</td></tr>
</tbody></table>
<h3 id="dl-first"><a class="header" href="#dl-first">DL First</a></h3>
<p>One fairly simple approach is to solve the DL piece first (like you would in the cross), then solve the other 2 pairs individually. This approach is quite useful but don't rely on it to give you the best solutions all the time.</p>
<p><strong>Example 1:</strong></p>
<div id="inf2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`D U R U' R U2 F' U R U2 B`)
    ('#inf2');
</script>
<p>This approach is very rudimentary but can get you going (for now).</p>
<p><code>D</code> solves DL into its place, then <code>U R U' R</code> pairs up the blue-red-white pair in a CFOP-like manner, which can then be inserted into its slot with <code>U2 F'</code>. Next, the other pair can be paired up in 2 moves (<code>U R</code>) which then can be solved either by doing <code>U2 B</code> like shown in the visual cube, or <code>r2 B'</code>. Both these approaches for inserting pairs are very useful to get used to - try to break CFOP habits for FB when it comes to inserting pairs into their respective slots.</p>
</div>
<p><strong>Example 2:</strong></p>
<div id="inf3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`D M' U2 B U2 r' U' R' F`)
    ('#inf3');
</script>
<p>This approach is very rudimentary but can get you going (for now).</p>
<p><code>D</code> solves DL into its place, <code>M'</code> pairs the blue-orange-white pair up, which is then inserted using <code>U2 B</code>, which sets up the next pair to be solved with <code>U2 r' U'</code> to insert the edge to DF, then the corner can be paired up with <code>R'</code>, which can then be solved into its slot with <code>F</code>.</p>
</div>
<h3 id="line-line-2x2x1--pair"><a class="header" href="#line-line-2x2x1--pair">Line-Line 2x2x1 + Pair</a></h3>
<p>This is fairly hard to explain in words, but these examples should clear up doubts.</p>
<p><strong>Example 1:</strong></p>
<div id="inf4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`R' U' R' u U R' U2 B`)
    ('#inf4');
</script>
<p>For this example, the line-line already given by the scramble is the blue-red-white pair with two white pieces on bottom. This means that to get to a <code>2x2x1</code> square, all that needs to be done is to solve the blue center and the blue-red edge, which can be done either by doing some form of a <code>D</code> move or some form of a <code>u</code> move (which is used in the example shown above). The initial <code>R'</code> is done to setup the next pair - if you can't see this in inspection yet, you don't need to worry about it for now - then <code>U' R'</code> solves the square by pairing the center with the edge, then doing a <code>u</code> move solves a 2x2x1 square. Afterwards, the other pair is solved. (This pair could also be done with <code>U M' r B'</code>)</p>
</div>
<p><strong>Example 2:</strong></p>
<div id="inf5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`r' U' R2 D' U B`)
    ('#inf5');
</script>
<p>In this example, we have a center + edge solved, so we just need to solve the edge and corner corresponding to those pieces to solve the <code>2x2x1</code> square, then solve the pair afterwards. The line can be solved by doing <code>r' U' R2</code> which can then be solved into position with a <code>D'</code> move, then the remaining pair can be solved by doing <code>U B</code>.</p>
</div>
<h3 id="s-move-insert"><a class="header" href="#s-move-insert">S Move Insert</a></h3>
<p><strong>Example 1:</strong></p>
<div id="inf6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`M' U M' S' U' R' U2 F'`)
    ('#inf6');
</script>
<p>Usually an S move (or f move) insert can be done if there is a pair already solved. You can first position the cube where the pair is already solved (either at the back or at the front FB slot), then solve the DL edge and the center, then solve it into place with an S move of some sort. You can also <strong>solve the two pairs first, then insert the center and the edge last</strong> if it leads to a better solution.</p>
<p>In the example above, <code>M' U M'</code> is done to set up the edge and the center in a position where <code>S'</code> can insert it, then the last pair can be solved by doing <code>U' R' U2 F'</code>.</p>
</div>
<h3 id="line-line"><a class="header" href="#line-line">Line-Line</a></h3>
<p><strong>Example 1:</strong></p>
<div id="inf7">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    .case(`u2 F2 R' U' R D`)
    ('#inf7');
</script>
<p>The line-line approach is sometimes really useful, but forcing it usually doesn't yield great results. </p>
<p>For this case, <code>u2 F2</code> solves the edge <code>1x1x3</code> line, then <code>R' U' R</code> solves the corner <code>1x1x3</code> line, which can then be solved with a <code>D</code> move.</p>
</div>
<h2 id="other-resources-to-look-at-for-further-improvements"><a class="header" href="#other-resources-to-look-at-for-further-improvements">Other Resources to look at for further improvements:</a></h2>
<ul>
<li><a href="https://book.rouxers.com/fb.html">book.rouxers.com's FB page</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="second-block-1"><a class="header" href="#second-block-1">Second Block</a></h1>
<h2 id="objective-4"><a class="header" href="#objective-4">Objective</a></h2>
<p>The goal of Second Block (SB) is to solve a <code>2x3x1</code> block on the right side of the cube (opposite to the first block you built).</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#inf1');
</script>
</div>
<h2 id="basic-pair-insertions"><a class="header" href="#basic-pair-insertions">Basic Pair Insertions</a></h2>
<p>While you can treat this step similarly to CFOP except using the M slice to orient edges as opposed to rotating, <strong>this approach is fairly inefficient.</strong></p>
<p>When building SB, stick with a <code>&lt;R, r, U, M&gt;</code> moveset for now - there are places where doing F moves are useful, but as a beginner, avoiding using them completely for now will set somewhat decent fundamentals. Make sure to take SB slowly at the beginning and try to think of efficient solutions rather than blindly applying your knowledge from other methods.</p>
<p>Below are some inserts that are worth learning and setting up to when you see fit:</p>
<h3 id="wide-insert"><a class="header" href="#wide-insert">Wide Insert</a></h3>
<p>This insert is one of the most fundamental parts of Roux SB. </p>
<div id="inf2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`r U r'`)
    ('#inf2');
</script>
</div>
<p>There are quite a few cases where using the M slice to create this pair and insert this pair is going to be a good solution.</p>
<h3 id="wide-insert-2"><a class="header" href="#wide-insert-2">Wide Insert (2)</a></h3>
<div id="inf3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`r U' r'`)
    ('#inf3');
</script>
</div>
<p>This case is less commonly seen compared to the other wide insert shown above, but it is still good to know about this solution. Some people may also see this as <code>M'</code> to pair the corner and the edge, and then <code>R U' R'</code> to insert, but the <code>M'</code> and the <code>R</code> at the beginning cancels, so you end up with a beginning <code>r</code> move instead.</p>
<blockquote>
<p>The two cases above can, and should, be mirrored to the back with <code>r' U' r</code> and <code>r' U r</code> respectively.</p>
</blockquote>
<h3 id="corner-solved"><a class="header" href="#corner-solved">Corner Solved</a></h3>
<div id="corner1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`R U' M' U r'`)
    ('#corner1');
</script>
</div>
<p>When you have a misoriented edge and a solved corner, you can use the <code>M</code> slice to pair up the corner and the edge as shown above.</p>
<h3 id="corner-solved-2"><a class="header" href="#corner-solved-2">Corner Solved (2)</a></h3>
<div id="corner2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`r U' M U R'`)
    ('#corner2');
</script>
</div>
<p>When you have an oriented edge and a solved corner, you can use the <code>M</code> slice to pair up the corner and the edge as shown above.</p>
<h3 id="regular-inserts"><a class="header" href="#regular-inserts">Regular Inserts</a></h3>
<p>The normal CFOP style with moveset <code>&lt;RU&gt;</code> to insert pairs should also be used in Roux SB. If you ever need to use F moves (for example with <code>F' U' F</code>), you should instead use the M slice to orient the edge in question, then insert the pair using some form of <code>&lt;RrU&gt;</code>.</p>
<h2 id="approach-to-building-a-2x2x1-square"><a class="header" href="#approach-to-building-a-2x2x1-square">Approach to Building a 2x2x1 Square</a></h2>
<p>A <code>2x2x1</code> square is usually the first step of solving the second block, and can be built by either building the pair first, then doing some blockbuilding to solve the pair with the edge, or first solving the <code>DR</code> edge with some influencing, then solving any pair that comes afterwards.</p>
<p>Most top solvers solve the <code>DR</code> edge first mainly because it is easier to see FB + the <code>DR</code> edge in inspection. As a result, it is recommended that you use a <code>DR</code> first approach unless a pair presents itself for you after FB is built. </p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example 1</a></h3>
<div id="inf4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`M U r U' r'`)
    ('#inf4');
</script>
</div>
<p>While this pair is already solvable without rotating using CFOP, a <em>significantly</em> more efficient way of solving this pair would be to do an <code>M</code> move, then use one of the Roux-style wide inserts to solve the pair.</p>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example 2</a></h3>
<div id="inf5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`M R U' R'`)
    ('#inf5');
</script>
</div>
<p>The solution to this (without rotating or using <code>F</code>/<code>B</code> moves) is fairly obvious, but it's worth mentioning just in case.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example 3</a></h3>
<div id="inf6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`R U R' U r U' r'`)
    ('#inf6');
</script>
</div>
<p>This case may be somewhat difficult to think of on the spot, but this case essentially is setting the corner up to an <code>r U' r'</code> insert.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example 4</a></h3>
<div id="ben">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    .case(`r U' r' U2 r U r'`)
    ('#ben');
</script>
</div>
<p>This insert pairs up the corner and the edge with <code>r U' r'</code>, then the remaining portion is simply AUF into wide move insert.</p>
<h2 id="other-resources-to-look-at-for-further-improvements-1"><a class="header" href="#other-resources-to-look-at-for-further-improvements-1">Other Resources to look at for further improvements:</a></h2>
<p>Second Block is one of the hardest steps to get good at. It is highly recommended that you use the resources below to learn new approaches of solving SB rather than trying to learn everything by yourself.</p>
<ul>
<li>
<p>SBSquare (SS)</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=eGHJVvvbdXY">F2B Tech: Build your SS Pair &quot;Corner First&quot;</a></li>
<li><a href="https://onionhoney.github.io/roux-trainers/#ss">Zhouheng's SS Trainer</a></li>
</ul>
</li>
<li>
<p>SBPair (SP)</p>
<ul>
<li><a href="https://docs.google.com/document/d/1bX50jAOM_veHsVJeLYGvSrH4uW9xrubep1zOSLdE4Vk/edit">Second Block Algs Document</a></li>
</ul>
</li>
<li>
<p>General Resources:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/Rouxles/roux-tutorial/master/fbdr/Zhouheng%27s%20FBDR%20Guide.pdf">Zhouheng's FBDR Guide</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLXiPs1z2Pwm5QPrtqB5J5rJ2DH6tbBU8T">Kavin Tangtartharakul's Example Solves</a></li>
<li><a href="https://cubegrass.appspot.com/block_trainer/">Cubegrass SB, SS, SP Trainers</a></li>
</ul>
</li>
<li>
<p><a href="https://book.rouxers.com/fb.html">book.rouxers.com's FB page</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="cmll-1"><a class="header" href="#cmll-1">CMLL</a></h1>
<h2 id="objective-5"><a class="header" href="#objective-5">Objective</a></h2>
<p>The goal of CMLL is to solve the corners on the <code>U</code> layer - both oriented and permuted as shown in the figure below.</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#inf1');
</script>
</div>
<p>This is an algorithmic step. As a result there is not much to mention other than to use the following algsheets:</p>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/1EdCeGlotJ76MyVw02_N1El_SXXSIMJRhYvZn4gZkQk8/edit#gid=2073570715">2 Look CMLL</a> (For those that want a stopgap option to test the Roux method)</li>
<li><a href="https://docs.google.com/spreadsheets/d/1uc5V3G-kRH3qV5b6Lq1yzTjnqSMS3D3dZcsCIOiJqcI/edit">2H CMLL</a> (A list of CMLL algs intended for 3x3 solving)</li>
<li><a href="https://docs.google.com/spreadsheets/d/1WHnksK4yyv63sv3Es-PuKfnFRtZGafqp6rEuEfOx-cg/edit">OH CMLL</a> (A list of CMLL algs intended for OH solving)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="lse-1"><a class="header" href="#lse-1">LSE</a></h1>
<h2 id="objective-6"><a class="header" href="#objective-6">Objective</a></h2>
<h2 id="edge-orientation-eo-1"><a class="header" href="#edge-orientation-eo-1">Edge Orientation (EO)</a></h2>
<p>The first 'step' of LSE is to orient all the edges. This means that assuming you solve your blocks with white or yellow on the <code>D</code> layer, you would want all the white/yellow facelets to be on the <code>U</code> or <code>D</code> face as shown by the purple facelets in the visual below.</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wmwwtwwmwggggggglgrlrrtrrlrymymmmymybbbbbbblbolootoolo')
    ('#inf1');
</script>
</div>
<p>This step can be done by setting up to an <em>arrow</em> case.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
